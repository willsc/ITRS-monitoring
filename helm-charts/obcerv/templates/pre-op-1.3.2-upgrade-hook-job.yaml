---
apiVersion: v1
kind: ConfigMap
metadata:
  name: pre-upgrade-scripts
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
    app.kubernetes.io/instance: {{ .Release.Name | quote }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
    helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
  annotations:
    "helm.sh/hook": pre-upgrade
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation
data:
  stop-fes-and-wait-for-zero-lag.sh: |-
    #!/bin/bash

    set -e

    MESHED="{{ .Values.tls.internal.enabled }}"

    doExit ()
    {
      if [ ! -z "$MESHED" ] && [ $MESHED == true ]
      then
        curl -s -X POST http://localhost:4191/shutdown || true
      fi
      exit $1
    }

    FES_API_URL="https://$KUBERNETES_SERVICE_HOST/apis/apps/v1/namespaces/$NAMESPACE/deployments/final-entity-stream"
    KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    KUBE_CACRT_PATH="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    PAYLOAD="{\"spec\":{\"replicas\":0}}"
    
    status_code=$(curl -s --cacert $KUBE_CACRT_PATH -H "Authorization: Bearer $KUBE_TOKEN" -w "%{http_code}" \
    -X PATCH -H "Content-Type: application/strategic-merge-patch+json" --data $PAYLOAD --output /dev/null $FES_API_URL)
    
    if [[ "$status_code" -ne 200 ]] ; then
      echo "Non-success code from scale down request of FES"
      doExit 1
    else
      echo "Scaled down FES deployment"
    fi

    remainingWaitSeconds=600

    while [[ $(curl -s --cacert $KUBE_CACRT_PATH -H "Authorization: Bearer $KUBE_TOKEN" $FES_API_URL | grep '"replicas": 1' ) ]]; do
      echo "Waiting for final-entity-stream to terminate..."

      if [[ $remainingWaitSeconds -le 0 ]]; then
        echo "Giving up wait for final-entity-stream replicas to terminate - exiting"
        doExit 1
      fi

      sleep 10
      remainingWaitSeconds=$((remainingWaitSeconds-10))
    done

    partitionLagOutput=""

    checkLag ()
    {
      unset check_lag_std_err check_lag_std_out

      eval "$( (/opt/kafka/bin/kafka-consumer-groups.sh --bootstrap-server $KAFKA_BROKERS --group entity-attribute \
      --describe | tail -n +3 | awk '{print $6}' | grep -e "^[1-9]" ) 2> >(check_lag_std_err=$(cat); typeset -p check_lag_std_err) \
      > >(check_lag_std_out=$(cat); typeset -p check_lag_std_out) )"

      if [[ $(echo $check_lag_std_err | grep -v "Consumer group 'entity-attribute'") ]]; then
        echo "Check lag request failed with error $check_lag_std_err - exiting"
        doExit 1
      fi

      echo -e "Got non-zero responses for partition lag on entity-attribute consumer: \n$check_lag_std_out"
      partitionLagOutput="$check_lag_std_out"
    }

    checkLag
    while [[ ! -z "$partitionLagOutput" ]]; do

      if [[ $remainingWaitSeconds -le 0 ]]; then
        echo "Giving up wait for consumer entity-attribute to catch up - exiting"
        doExit 1
      fi

      echo "Lag exists for consumer group entity-attribute - waiting"
      sleep 10
      remainingWaitSeconds=$((remainingWaitSeconds-10))
    
      checkLag
    done

    echo "No lag for consumer group - exiting"
    doExit 0

---
apiVersion: batch/v1
kind: Job
metadata:
  name: "wait-for-zero-sinkd-lag-pre-upgrade-check-job"
  labels:
    app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
    app.kubernetes.io/instance: {{ .Release.Name | quote }}
    app.kubernetes.io/version: {{ .Chart.AppVersion }}
    helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
  annotations:
    "helm.sh/hook": pre-upgrade
    "helm.sh/hook-weight": "2"
    "helm.sh/hook-delete-policy": before-hook-creation
spec:
  ttlSecondsAfterFinished: 600
  backoffLimit: 5
  template:
    metadata:
      name: "wait-for-zero-sinkd-lag-pre-upgrade-check-job"
      labels:
        app.kubernetes.io/managed-by: {{ .Release.Service | quote }}
        app.kubernetes.io/instance: {{ .Release.Name | quote }}
        helm.sh/chart: "{{ .Chart.Name }}-{{ .Chart.Version }}"
      annotations:
      {{- if .Values.tls.internal.enabled }}
        linkerd.io/inject: enabled
        {{- with .Values.mesh.resourcesHot }}
        {{- toYaml . | nindent 8 }}
        {{- end }}
      {{- end }}
    spec:
      restartPolicy: Never
      serviceAccountName: obcerv-operator
      imagePullSecrets:
      - name: {{ .Values.docker.secret }}
      securityContext:
        fsGroup: 10000
      containers:
      - name: wait-for-zero-sinkd-lag-pre-upgrade-check-job
        image: "{{ .Values.docker.registry }}/{{ .Values.kafka.image }}:{{ .Values.platformImageTag }}"
        imagePullPolicy: {{ .Values.defaultImagePullPolicy }}
        command:
        - /app/resources/stop-fes-and-wait-for-zero-lag.sh
        securityContext:
          runAsNonRoot: true
          runAsGroup: 10000
          runAsUser: 10000
        env:
        - name: KAFKA_BROKERS
          value: "kafka.{{ .Release.Namespace }}.svc.cluster.local:{{ .Values.kafka.clientPort }}"
        - name: NAMESPACE
          value: {{ .Release.Namespace }}
        - name: SERVICE_ACCOUNT
          value: obcerv-operator
        volumeMounts:
        - name: resources
          mountPath: /app/resources
          readOnly: true
      volumes:
      - name: resources
        configMap:
          name: pre-upgrade-scripts
          defaultMode: 0550